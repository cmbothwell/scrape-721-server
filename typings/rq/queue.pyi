"""
This type stub file was generated by pyright.
"""

from collections import namedtuple
from .compat import total_ordering

def compact(lst): # -> list[Unknown]:
    ...

class EnqueueData(namedtuple('EnqueueData', ["func", "args", "kwargs", "timeout", "result_ttl", "ttl", "failure_ttl", "description", "job_id", "at_front", "meta", "retry"])):
    """Helper type to use when calling """
    __slots__ = ...


@total_ordering
class Queue:
    job_class = ...
    DEFAULT_TIMEOUT = ...
    redis_queue_namespace_prefix = ...
    redis_queues_keys = ...
    @classmethod
    def all(cls, connection=..., job_class=..., serializer=...): # -> list[Self@Queue]:
        """Returns an iterable of all Queue"""
        ...
    
    @classmethod
    def from_queue_key(cls, queue_key, connection=..., job_class=..., serializer=...): # -> Self@Queue:
        """Returns a Queue instance, based """
        ...
    
    def __init__(self, name=..., default_timeout=..., connection=..., is_async=..., job_class=..., serializer=..., **kwargs) -> None:
        ...
    
    def __len__(self):
        ...
    
    def __nonzero__(self): # -> Literal[True]:
        ...
    
    def __bool__(self): # -> Literal[True]:
        ...
    
    def __iter__(self): # -> Generator[Self@Queue, None, None]:
        ...
    
    def get_redis_server_version(self): # -> tuple[int, ...] | tuple[Literal[5], Literal[0], Literal[9]]:
        """Return Redis server version of c"""
        ...
    
    @property
    def key(self): # -> str:
        """Returns the Redis key for this Q"""
        ...
    
    @property
    def registry_cleaning_key(self): # -> str:
        """Redis key used to indicate this """
        ...
    
    def acquire_cleaning_lock(self):
        """Returns a boolean indicating whe"""
        ...
    
    def empty(self):
        """Removes all messages on the queu"""
        ...
    
    def delete(self, delete_jobs=...): # -> None:
        """Deletes the queue. If delete_job"""
        ...
    
    def is_empty(self):
        """Returns whether the current queu"""
        ...
    
    @property
    def is_async(self): # -> bool:
        """Returns whether the current queu"""
        ...
    
    def fetch_job(self, job_id): # -> Job | Any | None:
        ...
    
    def get_job_position(self, job_or_id): # -> int | None:
        """Returns the position of a job wi"""
        ...
    
    def get_job_ids(self, offset=..., length=...): # -> list[str | None]:
        """Returns a slice of job IDs in th"""
        ...
    
    def get_jobs(self, offset=..., length=...): # -> list[Job | Any | Unknown]:
        """Returns a slice of jobs in the q"""
        ...
    
    @property
    def job_ids(self): # -> list[str | None]:
        """Returns a list of all job IDS in"""
        ...
    
    @property
    def jobs(self): # -> list[Job | Any | Unknown]:
        """Returns a list of all (valid) jo"""
        ...
    
    @property
    def count(self):
        """Returns a count of all messages """
        ...
    
    @property
    def failed_job_registry(self): # -> FailedJobRegistry:
        """Returns this queue's FailedJobRe"""
        ...
    
    @property
    def started_job_registry(self): # -> StartedJobRegistry:
        """Returns this queue's StartedJobR"""
        ...
    
    @property
    def finished_job_registry(self): # -> FinishedJobRegistry:
        """Returns this queue's FinishedJob"""
        ...
    
    @property
    def deferred_job_registry(self): # -> DeferredJobRegistry:
        """Returns this queue's DeferredJob"""
        ...
    
    @property
    def scheduled_job_registry(self): # -> ScheduledJobRegistry:
        """Returns this queue's ScheduledJo"""
        ...
    
    @property
    def canceled_job_registry(self): # -> CanceledJobRegistry:
        """Returns this queue's CanceledJob"""
        ...
    
    def remove(self, job_or_id, pipeline=...):
        """Removes Job from queue, accepts """
        ...
    
    def compact(self): # -> None:
        """Removes all "dead" jobs from the"""
        ...
    
    def push_job_id(self, job_id, pipeline=..., at_front=...): # -> None:
        """Pushes a job ID on the correspon"""
        ...
    
    def create_job(self, func, args=..., kwargs=..., timeout=..., result_ttl=..., ttl=..., failure_ttl=..., description=..., depends_on=..., job_id=..., meta=..., status=..., retry=..., *, on_success=..., on_failure=...): # -> Any:
        """Creates a job based on parameter"""
        ...
    
    def setup_dependencies(self, job, pipeline=...):
        ...
    
    def enqueue_call(self, func, args=..., kwargs=..., timeout=..., result_ttl=..., ttl=..., failure_ttl=..., description=..., depends_on=..., job_id=..., at_front=..., meta=..., retry=..., on_success=..., on_failure=..., pipeline=...):
        """Creates a job to represent the d"""
        ...
    
    @staticmethod
    def prepare_data(func, args=..., kwargs=..., timeout=..., result_ttl=..., ttl=..., failure_ttl=..., description=..., job_id=..., at_front=..., meta=..., retry=...): # -> EnqueueData:
        ...
    
    def enqueue_many(self, job_datas, pipeline=...): # -> list[Unknown | Any]:
        """
        Creates multiple jobs ("""
        ...
    
    def run_job(self, job):
        ...
    
    @classmethod
    def parse_args(cls, f, *args, **kwargs): # -> tuple[str | Unknown, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | bool, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | None, Unknown | tuple[Unknown, ...] | None, Unknown | dict[str, Unknown] | None]:
        """
        Parses arguments passed"""
        ...
    
    def enqueue(self, f, *args, **kwargs):
        """Creates a job to represent the d"""
        ...
    
    def enqueue_at(self, datetime, f, *args, **kwargs): # -> Any:
        """Schedules a job to be enqueued a"""
        ...
    
    def schedule_job(self, job, datetime, pipeline=...):
        """Puts job on ScheduledJobRegistry"""
        ...
    
    def enqueue_in(self, time_delta, func, *args, **kwargs): # -> Any:
        """Schedules a job to be executed i"""
        ...
    
    def enqueue_job(self, job, pipeline=..., at_front=...):
        """Enqueues a job for delayed execu"""
        ...
    
    def run_sync(self, job):
        ...
    
    def enqueue_dependents(self, job, pipeline=...):
        """Enqueues all jobs in the given j"""
        ...
    
    def pop_job_id(self): # -> str | None:
        """Pops a given job ID from this Re"""
        ...
    
    @classmethod
    def lpop(cls, queue_keys, timeout, connection=...): # -> tuple[Unknown, Unknown] | None:
        """Helper method.  Intermediate met"""
        ...
    
    @classmethod
    def dequeue_any(cls, queues, timeout, connection=..., job_class=..., serializer=...): # -> tuple[Any | Unknown, Self@Queue] | None:
        """Class method returning the job_c"""
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __lt__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


