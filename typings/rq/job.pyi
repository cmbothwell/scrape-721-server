"""
This type stub file was generated by pyright.
"""

from enum import Enum

dumps = ...
loads = ...
class JobStatus(str, Enum):
    QUEUED = ...
    FINISHED = ...
    FAILED = ...
    STARTED = ...
    DEFERRED = ...
    SCHEDULED = ...
    STOPPED = ...
    CANCELED = ...


UNEVALUATED = ...
def cancel_job(job_id, connection=..., serializer=..., enqueue_dependents=...): # -> None:
    """Cancels the job with the given j"""
    ...

def get_current_job(connection=..., job_class=...): # -> None:
    """Returns the Job instance that is"""
    ...

def requeue_job(job_id, connection, serializer=...): # -> Job | Any:
    ...

class Job:
    """A Job is just a convenient datas"""
    redis_job_namespace_prefix = ...
    @classmethod
    def create(cls, func, args=..., kwargs=..., connection=..., result_ttl=..., ttl=..., status=..., description=..., depends_on=..., timeout=..., id=..., origin=..., meta=..., failure_ttl=..., serializer=..., *, on_success=..., on_failure=...):
        """Creates a new Job instance for t"""
        ...
    
    def get_position(self): # -> int | None:
        ...
    
    def get_status(self, refresh=...): # -> str | JobStatus | None:
        ...
    
    def set_status(self, status, pipeline=...): # -> None:
        ...
    
    def get_meta(self, refresh=...): # -> Any | dict[Unknown, Unknown]:
        ...
    
    @property
    def is_finished(self): # -> bool:
        ...
    
    @property
    def is_queued(self): # -> bool:
        ...
    
    @property
    def is_failed(self): # -> bool:
        ...
    
    @property
    def is_started(self): # -> bool:
        ...
    
    @property
    def is_deferred(self): # -> bool:
        ...
    
    @property
    def is_canceled(self): # -> bool:
        ...
    
    @property
    def is_scheduled(self): # -> bool:
        ...
    
    @property
    def is_stopped(self): # -> bool:
        ...
    
    @property
    def dependency(self): # -> Self@Job | None:
        """Returns a job's first dependency"""
        ...
    
    @property
    def dependent_ids(self): # -> list[str | None]:
        """Returns a list of ids of jobs wh"""
        ...
    
    @property
    def func(self): # -> Any | None:
        ...
    
    @property
    def success_callback(self): # -> Any | object | None:
        ...
    
    @property
    def failure_callback(self): # -> Any | object | None:
        ...
    
    @property
    def data(self): # -> bytes | Any | object:
        ...
    
    @data.setter
    def data(self, value): # -> None:
        ...
    
    @property
    def func_name(self): # -> Any | object:
        ...
    
    @func_name.setter
    def func_name(self, value): # -> None:
        ...
    
    @property
    def instance(self): # -> Any | object | None:
        ...
    
    @instance.setter
    def instance(self, value): # -> None:
        ...
    
    @property
    def args(self): # -> Any | tuple[()] | object:
        ...
    
    @args.setter
    def args(self, value): # -> None:
        ...
    
    @property
    def kwargs(self): # -> Any | object | dict[Unknown, Unknown]:
        ...
    
    @kwargs.setter
    def kwargs(self, value): # -> None:
        ...
    
    @classmethod
    def exists(cls, job_id, connection=...):
        """Returns whether a job hash exist"""
        ...
    
    @classmethod
    def fetch(cls, id, connection=..., serializer=...): # -> Self@Job:
        """Fetches a persisted job from its"""
        ...
    
    @classmethod
    def fetch_many(cls, job_ids, connection, serializer=...): # -> list[Unknown]:
        """
        Bulk version of Job.fet"""
        ...
    
    def __init__(self, id=..., connection=..., serializer=...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def get_id(self): # -> str:
        """The job ID for this job instance"""
        ...
    
    def set_id(self, value): # -> None:
        """Sets a job ID for the given job."""
        ...
    
    def heartbeat(self, timestamp, ttl, pipeline=..., xx=...): # -> None:
        ...
    
    id = ...
    @classmethod
    def key_for(cls, job_id):
        """The Redis key that is used to st"""
        ...
    
    @classmethod
    def dependents_key_for(cls, job_id): # -> str:
        """The Redis key that is used to st"""
        ...
    
    @property
    def key(self): # -> Any:
        """The Redis key that is used to st"""
        ...
    
    @property
    def dependents_key(self): # -> str:
        """The Redis key that is used to st"""
        ...
    
    @property
    def dependencies_key(self): # -> str:
        ...
    
    def fetch_dependencies(self, watch=..., pipeline=...): # -> list[Unknown]:
        """
        Fetch all of a job's de"""
        ...
    
    @property
    def result(self): # -> Any | str | None:
        """Returns the return value of the """
        ...
    
    return_value = ...
    def restore(self, raw_data):
        """Overwrite properties with the pr"""
        ...
    
    def refresh(self): # -> None:
        """Overwrite the current instance's"""
        ...
    
    def to_dict(self, include_meta=...):
        """
        Returns a serialization"""
        ...
    
    def save(self, pipeline=..., include_meta=...): # -> None:
        """
        Dumps the current job i"""
        ...
    
    def get_redis_server_version(self): # -> tuple[int, ...] | tuple[Literal[5], Literal[0], Literal[9]]:
        """Return Redis server version of c"""
        ...
    
    def save_meta(self): # -> None:
        """Stores job meta from the job ins"""
        ...
    
    def cancel(self, pipeline=..., enqueue_dependents=...):
        """Cancels the given job, which wil"""
        ...
    
    def requeue(self): # -> Job | Any:
        """Requeues job."""
        ...
    
    def delete(self, pipeline=..., remove_from_queue=..., delete_dependents=...): # -> None:
        """Cancels the job and deletes the """
        ...
    
    def delete_dependents(self, pipeline=...): # -> None:
        """Delete jobs depending on this jo"""
        ...
    
    def perform(self): # -> Any:
        """Invokes the job function with th"""
        ...
    
    def prepare_for_execution(self, worker_name, pipeline): # -> None:
        """Set job metadata before executio"""
        ...
    
    def get_ttl(self, default_ttl=...): # -> int | None:
        """Returns ttl for a job that deter"""
        ...
    
    def get_result_ttl(self, default_ttl=...): # -> int | None:
        """Returns ttl for a job that deter"""
        ...
    
    def get_call_string(self): # -> str | None:
        """Returns a string representation """
        ...
    
    def cleanup(self, ttl=..., pipeline=..., remove_from_queue=...): # -> None:
        """Prepare job for eventual deletio"""
        ...
    
    @property
    def started_job_registry(self): # -> StartedJobRegistry:
        ...
    
    @property
    def failed_job_registry(self): # -> FailedJobRegistry:
        ...
    
    def get_retry_interval(self): # -> Any | Literal[0]:
        """Returns the desired retry interv"""
        ...
    
    def retry(self, queue, pipeline): # -> None:
        """Requeue or schedule this job for"""
        ...
    
    def register_dependency(self, pipeline=...): # -> None:
        """Jobs may have dependencies. Jobs"""
        ...
    
    @property
    def dependency_ids(self): # -> list[Unknown]:
        ...
    
    def dependencies_are_met(self, exclude_job_id=..., pipeline=...): # -> bool:
        """Returns a boolean indicating if """
        ...
    


_job_stack = ...
class Retry:
    def __init__(self, max, interval=...) -> None:
        """`interval` can be a positive num"""
        ...
    


